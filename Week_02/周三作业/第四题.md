4.（必做） 根据上述自己对于 1 和 2 的演示，写一段对于不同 GC 的总结，提交到 Github

512m - 2021-01-24T18:05:33.421+0800: 0.310: [GC (Allocation Failure) 2021-01-24T18:05:33.421+0800: 0.310: [DefNew
: 139602K->17472K(157248K), 0.0336850 secs] 139602K->40213K(506816K), 0.0338387 secs] [Times: user=0.00 sys=0.03, real=0.03 secs]
1024m -2021-01-23T20:25:42.785+0800: 0.259: [GC (Allocation Failure) 2021-01-23T20:25:42.785+0800: 0.260: [DefNew
: 139248K->17471K(157248K), 0.0245775 secs] 139248K->36177K(506816K), 0.0247607 secs] [Times: user=0.00 sys=0.03, real=0.02 secs]
512m SerialGC日志 总结

1. 2021-01-24T18:05:33.421+0800:0.310-GC事件开始的时间点,其中+0800表示当前时区为东八区,0.310表示GC事件相对于启动时间的间隔,单位是秒

2. GC (Allocation Failure):GC用来区分是MinorGC还是FullGC的标志.GC表示这是一次小型GC(MinorGC),即年轻代GC.
   Allocation Failure表示GC触发的原因.本次GC事件,由于对象分配失败,年轻代中没有空间来存放新生成的对象引起的.

3. DefNew:139602K->17472K(157248K), 0.0336850 secs: DefNew 表示垃圾收集器的名称,DefNew表示年轻代使用的单线程标记复制 STW垃圾收集器.  
   139602K->17472K(157248K)表示垃圾收集之前和之后的年轻代使用量.157248K表示年轻代的总空间大小.进一步分析可以知道:GC之后年轻代使用率为11% 
   0.0336850 secs-表示这次DefNew事件持续的时间,以秒为单位

4. 139602K->40213K(506816K)-表示在垃圾收集之前和之后整个堆内存的使用情况,506816K表示堆内存可用的总空间大小.进一步分析可知:GC之后堆内存使用量为8%
   0.0338387 secs表示GC事件持续的时间,以秒为单位

5.[Times: user=0.00 sys=0.03, real=0.03 secs]-此次GC事件的持续时间,通过三个部分来衡量:user部分表示所有GC线程消耗的CPU时间;sys部分表示系统
  调用和系统等待事件消耗的时间.real表示应用程序暂停的时间.因为串行垃圾收集器只用单个线程,索引这里real=user+sys

>>总结:根据上面的解读,我们可以分析JVM在GC事件中的内存使用以及变化情况.在此次垃圾收集之前,堆内存的使用量为139602K,其中年轻代使用了139602K,因此可以算出
GC之前老年代空间的使用量为0

进一步分析,得出更重要的信息:GC前后对比,年轻代的使用量为139602K->17472K,减少了122130K,但是堆内存的中使用量139602K->40213K只下降了99389K.
因此可以算出,从年轻代提升到老年代的对象占用了122130K-99389K=22741K的内存空间.当然.另一组数字也能推算出GC之后老年代的使用量40213K-17472K=22741K

我们关注的主要是两个数据:GC暂停时间,以及GC之后的内存使用量/使用率

FullGC日志分析:
512m - 2021-01-24T18:05:33.898+0800: 0.788: [GC (Allocation Failure) 2021-01-24T18:05:33.898+0800: 0.788: [DefNew
: 157246K->157246K(157248K), 0.0000129 secs]2021-01-24T18:05:33.898+0800: 0.788: [Tenured: 323002K->279699K(349568K), 0.0432524 secs] 480248K->279699K(506816K), [Metaspace: 2616K->2616K(1056768K)], 0.0433397 secs] [Times: user=0.05 sys=0.00, real=0.04 secs]
1024m -2021-01-23T20:25:43.189+0800: 0.664: [GC (Allocation Failure) 2021-01-23T20:25:43.189+0800: 0.664: [DefNew
: 157247K->157247K(157248K), 0.0000129 secs]2021-01-23T20:25:43.189+0800: 0.664: [Tenured: 330574K->277744K(349568K), 0.0447881 secs] 487822K->277744K(506816K), [Metaspace: 2616K->2616K(1056768K)], 0.0448771 secs] [Times: user=0.05 sys=0.00, real=0.05 secs]

从中可以解读出的信息:
1. 2021-01-24T18:05:33.898+0800-GC事件开始的时间
2. [DefNew: 157246K->157246K(157248K), 0.0000129 secs]-因为内存分配失败,发生了一次年轻代GC.此次GC同样用的DefNew收集器,此次垃圾收集器
消耗了0.0000129 secs.基本上确认了本次GC事件没怎么处理年轻代,157246K->157246K 垃圾收集之前和之后的年轻代的使用量来看,也是如此
3. [Tenured: 323002K->279699K(349568K), 0.0432524 secs]-Tenured用于清理老年代空间的垃圾收集器名称.Tenured表明使用的是单线程的STW垃圾
收集器,使用的算法为 标记-清除-整理(mark-sweep-compact).323002K->279699K(349568K):表示GC前后老年代的使用量,以及老年代的空间大小,0.0432524 
secs是清理老年代所花的时间
4. 480248K->279699K(506816K)-在GC前后整个堆内存部分的使用情况,以及可用的堆空间的大小.
5. [Metaspace: 2616K->2616K(1056768K)]-Metaspace空间的变化情况.可以看出,此次GC过程中Metaspace没有什么变化
6. [Times: user=0.05 sys=0.00, real=0.04 secs]-GC事件的持续时间,分为user sys real三个部分.因为串行垃圾收集器只使用单个线程,因此real=
sys+user.50ms的暂停时间,比起前面年轻代的GC来说增加了一倍作用,[GC时间,与GC后的存活的对象的总数量关系很大]

进一步分析这些数据,GC之后老年代的使用率为:279699K/349568K=80%
和年轻代相比,比较明显的差别是此次GC事件清理了老年代和Metaspace

>> 总结:FullGC,我们主要关注GC之后内存使用是否下降,其次关注暂停时间.简单估计,GC后老年代使用量为280MB左右,耗时50ms.如果内存扩大10倍,GC后老年代内
>存使用量也扩大10倍,那耗时可能就是500ms甚至更高,那时系统就会有很明显的影响了.这也是我们说串行GC性能弱的一个原因,服务端一般不会采用串行GCde 

使用512m内存与使用1g内存,两者几乎没有区别










